const translate = {
  'Level Three': {
    Title: `ダッシュボード作成を極める`,
    Level: `レベル３：`
  },
  Introduction_L3: {
    Title: 'はじめに',
    Contents: {
      P1: `
        レベル3へようこそ。ここまでよく付いてきてくれました！
        ご利用中の実際の状況でクエリの結果や説明の例をご覧いただくことで、
        データをパワフルに可視化する方法をより深く理解していただけるものと思います。
        （このコースのクエリを、ご利用中のアカウントの様々なイベントタイプで試していただき、
        そのパワーを実感してください！）
      `,
      P2: `
        それでは、次はより高度なコンセプトのご紹介をしましょう。
        これからご紹介する関数や機能は常に使うものではないかもしれませんが、
        使い慣れておくことをおすすめします。
        特定の課題や要件に立ち向かうために必要になるでしょう。
      `,
      P3: `
        このレベルでは、場合分けを使ったFACET、高度な集計関数、
        EXTRAPOLATEキーワードを使った値の取得、フィルタを使った集計関数、
        そして値のオーバーライドをご紹介します。
      `
    }
  },
  'Advanced aggregators': {
    Title: '高度な集計機能',
    Contents: {
      P1: `
        New Relicは様々な集計機能を提供しています。
        それぞれの関数はそれぞれ異なる、便利な目的を提供しています。
        このレッスンでは、Rate, Funnnel, Filter, Histogram, Apdexの集計関数を体験して、
        より高度な疑問の答えを見つけられるようになるでしょう。
      `,
      H1: '「単位時間当たり」を計算する',
      P2: `
        <1>rate()</1> 関数から始めてみましょう。
        この関数を使うことにより、単位時間当たりの頻度を可視化することができます。
        小さい時間間隔での頻度を長い時間範囲に渡って理解したいときに有用です。
      `,
      P3: `
        次の例では、過去1時間の範囲で、5分当たりの平均リクエスト数を取得できます。
        また、その前の1時間における5分当たりの平均リクエスト数と比較しています。
        このクエリでは <3>SINCE 1 hour ago</3> を指定して、この時間範囲における値を
        計算しています。
      `,
      P4: `
        <1>rate()</1> は時間間隔を指定することで、
        <4>1分当たりのリクエスト</4>や<6>1秒辺りのリクエスト数</6>を計算することもできます。
      `,
      H2: 'ファネル図',
      P5: `
        エンドユーザーの行動を分析するために、ファネル図をお使いの方も多いことでしょう。
        ファネル図を使うことで、複数のレコードに渡る属性値の発生率を追跡できます。
        ユーザーの進捗状況が定義された経路に沿ってどのように上手く進んでいるかを可視化するときによく使われ、
        特にカスタムアトリビュートと組み合わせて使うと強力です。
      `,
      P6: `
        どのくらいのユーザーがトップページを開き、次に他のページを開いているかを、
        <1>funnel()</1> 集計関数を使って可視化してみましょう。
        1つ目のパラメーターで、ユニークなものとして扱うアトリビュートを特定します。
        この例では、New Relic Browserは（cookieの利用を有効にしている場合）サイトを訪れるユーザーに対して
        それぞれ <4>session</4> IDを割り当て、記録しています。
        カスタムアトリビュートで独自のセッションIDをセットすることもできます。
      `,
      P7: `
        続くパラメーターで、ファネルの各ステップをどのように計算するかを指定します。
        "<1>, WHERE アトリビュート 演算子 値</1>" の形式で記述します。
        この例では、2つのステップを指定しています。
        まず、トップページを訪れるたユニークなユーザー数を求め、
        次に、他のページに遷移したユーザーの数を求めています。
        <3>ご利用のデータで妥当そうな結果が得られるか、試してみてください。</3>
      `,
      H3: '集計フィルタ',
      P8: `
        <0>filter()</0> は集計の結果に含まれるイベントをより制御できるようするもので、
        1つのクエリで複数のデータポイントを集計するときに威力を発揮します。
        この例では、 <3>filter()</3> を使ってTransactionイベントから
        ウェブトランザクションおよび非ウェブトランザクションそれぞれの値を返すようにしています。
      `,
      P9: `
        この結果は数値を返しており、結果をさらに演算させることもできます。
        例えば、全てのトランザクションに占めるウェブトランザクションの割合を求めるには、
        次のようなクエリになります：
      `,
      H4: 'ヒストグラム',
      P10: `
        ヒストグラムを使うと、データの分布をわかりやすく可視化できるようになります。
        単なる平均だけではなく、データポイントがどのような頻度で出現するかを理解するときに役立ちます。
        <1>histogram()</1> 関数は3つの引数を取ります：
        <3>
          <0>プロットしたい属性（durationなど）</0>
          <1>分析したい範囲の最大値（"1"の場合、1秒以下を分析する）</1>
          <2>グループ化するときのバケット数</2>
        </3>
        次の例では、 <5>histogram()</5>を使って、
        0〜1秒のduration値に対して、50msずつに分割したバケットでグループ化したチャートを作っています。
        バケット数には20を指定しています。
        1秒を超えるdurationのものは、最後のバケットにまとめられます。
      `,
      H5: 'Apdex',
      P11: `
        <1>apdex()</1>関数を使うと、あらゆる数値（durationなど）のApdexスコアが計算できます。
        特定のトランザクションやカスタムアトリビュートの値に対するApdex値を計算することができるようになり、
        また、APMの設定を変えることなく、独自のApdex-T値を与えることもできます。
        次の例では、"duration"値に対して、Apdex−Tを0.08にしたときのApdex値を求めています：
      `,
      P12: `
        もちろん、<1>TIMESERIES</1> 句を指定して、範囲時間に渡るデータの変化をチャートにすることもできます。
        チャートには、「満足」「不満」「イライラ」の範囲も描画されます。
      `,
      H6: '本レッスンのまとめ',
      P13: `
        新たな可視化ツールである、<2>funnel()</2> と <4>histogram()</4> をご紹介しました。
        また、 <6>filter()</6> を使ってWHERE句でクエリを絞り込む方法と、
        <8>rate()</8> で属性の頻度を可視化する方法をご紹介しました。
      `,
      P14: `
        これらのクエリで、よりNRQLを使いこなすことができるようになります。
        Apdexは業界標準のスコアであり、多くの状況に適用できます。
        ファネル図は指定した経路の進捗状況を追跡できます。
        ヒストグラムはデータの分布を明確に可視化できます。
        フィルタは返却値を自在に絞り込むことができるようになります。
        次は、 <2>extrapolate</2> をご紹介しましょう。
      `
    }
  },
  'Using extrapolate': {
    Title: 'extrapolateを使用する',
    Contents: {
      P1: `
        New Relic Database (NRDB)は、膨大な量のデータを毎日、稲妻のようなスピードで受信し、処理しています。
        APMが大量のイベントデータを記録する際、New Relicエージェントはうまくサンプリングすることによって、
        実行中のアプリケーションへの影響を軽減しつつ、有意義なデータを継続的に収集するということを両立しています。
        通常、このような事態が発生するのは、あるイベントに大量のリクエストが集中したときに起こります。
        負荷分散された複数のインスタンスで上で複数のエージェントが稼働しているときには、
        ほとんど発生することはありません。
      `,
      P2: `
        では、実際に起ったときにどうするかについて見ていきましょう。
        <2>EXTRAPOLATE</2> 句は、New Relicに対してサンプリングの影響を数学的に補完させることができます。
        従って、あなたのシステムの実際の挙動に近い値が得られることになります。
        New Relicは上限値をどの程度超えたかという、特別な値を管理しています。
        それにより、統計的に精度の高い値を返すことができます。
      `,
      P3: `
        「もしかして、上限に引っかかっているかも？」と心配になったことはありますか？
        それなら、 <2>EXTRAPOLATE</2> 句を消して、クエリを実行してみましょう。
        結果が変わらなかったとしたら、上限は超えていないだろうと推測できます。
      `,
      H1: '本レッスンのまとめ',
      P4: `
        クエリの中で <1>EXTRAPOLATE</1> が指定された場合、
        該当するイベントとすべてのイベントとの割合が計算されます。
        この割合はサンプリングされなかったデータの近似を差し込む（extrapolate）ときに使われます。
        このキーワードは、すべてのクエリで有効になるわけではありません。
        サポートされていないクエリで指定されている場合、もしくはサンプリングされたデータではない場合、
        指定は無視されます。
      `,
      P5: `
        <1>EXTRAPOLATE</1> は、均質なデータ（スループットやエラーレートなど）に対して上手く動きます。
        個別の値を求めるようなクエリ（<4>uniqueCount()</4> や <6>uniques()</6> など）では、
        あまり上手く動きません。
        このキーワードは、下記の集計関数を使っているときに動作します：
      `
    }
  },
  'Facet cases': {
    Title: 'FACET CASES',
    Contents: {
      P1: `
        これまでのレッスンで、 <1>FACET</1> は値を分類したり、
        グループ化して状況を理解する（レスポンスコード別の平均レスポンスタイムを見たりするような場合の）ときに
        便利な手法であることを学んでいただきました。
        <3>FACET</3> を指定する、与えられたアトリビュート値を基にNRDBはデータをブループにまとめます。
        では、レスポンスコードが2xx, 3xx, 4xxのように、いくつかの値を同じグループとしてまとめたいときがあるでしょう。
        そのときは、どうしたらいいでしょうか？
      `,
      P2: `
        <0>FACET CASES</0> を使うと、このような状況でもうまくバケットを分けてクエリの結果が得られるようになります。
        この句は、"<2>WHERE attr OP value</2>" という形式の複数のパラメーターを取ります。
        次の例では、すべてのトランザクションイベントから、レスポンスコードが「2」で始まるものを「2xx Responses」として扱うようにしています。
        同じように、「3xx」「4xx」「5xx」のレスポンスコードもグループ化して、
        可読性を上げながら、アプリケーションで何が起こっているかを理解しやすくしています。
      `,
      P3: `
        このように、グループ化は便利ですが、読みやすいものではありません。
        ここで、Level2で学んだことを思い出してみましょう。
      `,
      H1: '本レッスンのまとめ',
      P4: `
        <0>FACET CASES</0> は、アトリビュートが持つ複数の値をまとめ、グループ化して扱えるようになります。
        この機能は多くの場面で便利に使うことができます。
        また、トランザクションデータの中にカスタムデータに対して、データの粒度を整えながらデータの可視化をコントロールするときに、
        さらに威力を発揮することでしょう。
      `
    }
  },
  'Filter by event type': {
    Title: 'イベントタイプによるフィルタ（結合の代替クエリ）',
    Contents: {
      P1: `
        皆様はすでにNRQLマスターになりつつあります!
        次にご紹介するのは、イベントタイプによるフィルタリングです。
      `,
      P2: `
        これまで学習したNRQLでは、1つのイベントタイプからデータを取得していました。
        しかし、2つの異なるイベントタイプに保存されているのデータを同時にプロットしたい場合どうすれば良いのでしょうか。
        なんと、NRQLのFROM句では、複数のイベントタイプを指定できるのです！
        以下のように、カンマで区切ることで複数のイベントタイプから情報を収集できるようになります。
      `,
      P3: `
        これをさらに便利に利用するために、<1>eventType()</1>関数を利用しましょう。
        この関数はレコードがどのイベントタイプのものであるかを教えてくれます。
        以下の例では、<4>Transaction</4> イベントと <6>PageView</6> イベントを
        同時にクエリしているのですが、
        <8>Transaction</8>と<10>PageView</10>それぞれの総数を別々に表示することができます。
      `,
      P4: `
        もう少し詳しく見てみましょう。<1>count(*)</1>は、
        <3>Transaction</3>と<5>PageView</5>の二つのイベントの総数となってしまいます。。
        しかし、皆様はもう<7>filter()</7>を使って<10>WHERE eventType()='PageView'</10>という条件を
        書けばフィルタできるということをご存知です。このように、イベントタイプごとの集合を全体の
        結果セットの一部として取得することで、特定のイベントのみのデータを表示することができます
        <13>TIMESERIES</13>を使えば、折れ線グラフで２つのデータを直接比較することができます。
      `,
      H1: '本レッスンのまとめ',
      P5: `
        2つの異なるイベントを指定し、それぞれのデータをフィルタする、そしてグラフとしてプロットすることが
        できるようになりました。NRQLでは、複雑な結合や結合クエリを書く必要なく、
        必要なデータを迅速かつ簡潔に取得できることをご確認いただけたと思います。
      `
    }
  },
  'Overriding values': {
    Title: '値をオーバーライドする',
    Contents: {
      H1: `NULL値をカウントする`,
      P1: `
        たまに欲しいデータがイベント内にない場合があります。
        例えば、計算するために数値が欲しいのに、文字列となっている場合があります。
        もしくはNULLとなっている場合なのですが、NULLは通常意味としては0と同じでしょう。
        この状況に対応するための機能があります。
      `,
      P2: `
        NULL値は、既定の属性値とカスタム属性双方に出てくることがあります。
        例えば<1>count()</1>や<4>average()</4>などの集約関数を利用する場合、
        NRQLは自動的にNULL値のあるイベントを除外して関数を実行します。
        そのようなイベントも除外せずに計算したい場合、NRQLでは、次のようにして
        予期せぬNULL値を考慮し"<6>OR value</6>"という句を利用できます。
        例えば"cartValue"という属性の NULL 値を 0 としてカウントしたい場合
        "cartValue OR 0"という記法となります。
      `,
      P3: `
        次の例では、<1>count()</1> を使ってApdexPerfZone属性が値を持っているトランザクション数をカウントします。
        ここで、"<3>OR 'Null</3>"を引数に指定すると、ApdexPerfZoneが存在する場合と、値がnullである場合の両方の
        すべてのトランザクション数をカウントできます。
      `,
      H2: `型強制`,
      P4: `
        NRQLは型強制を自動的には行いません。文字列は文字列として扱われるので、<1>sum()</1> や <3>average()</3>
        のような関数を利用できません。このような場合、<3>boolean()</3>または<5>numeric()</5>を使用して
        真偽値や数値に変換します。次の例で利用している<8>average()</8>関数で "httpResponseCode "
        属性を指定しても、値が取得できません。というのも、この属性が文字列だからです。
        しかし、<10>numeric</10>(httpResponseCode)を使って数値として型強制すると、
        <12>average()</12>関数は正常に動作します。
      `,
      P5: `
        もう一つの一般的な例として、BOOLEAN（TRUEまたはFALSE）値があります。
        文字列としてフォーマットされていることがよくあります。このような場合でも心配しないでください。
        イベントデータを送信する前に正しい値となるよう、プログラムを修正いただければ正しく計算されます。
        もう一つの方法は、ソースコードを修正するのではなく<1>boolean()</1>関数を使用してクエリを書くことです。
        もし属性の値が文字列の"TRUE"になっているのであれば、<3>boolean()</3>を使って型強制し、
        クエリを意図した通りに実行できるようにしましょう。
      `,
      P7: `
        また、<1>string()</1>関数を利用することにより、ブール値や数値を文字列に変換することができます。
        数値が小数点を含む値の場合、オプショナルの引数である<1>precision</1>で、小数点以下の桁数の制限を設定できます。
        このクエリはdurationの値を、小数点以下を3桁に制限した文字列として返却しています。
      `,
      H3: `本レッスンのまとめ`,
      P6: `
        神は細部に宿るといいます。このレッスンでは、データフォーマットを制御し、NRQLでどのように動作させたいかを指定することを学びました。
        New Relicのエージェントから送られてくるデータは一般的な利用方法を元にフォーマットされているのですが、
        もし独自のシナリオがありフォーマット変換を行う必要がある場合は、このレッスンで説明した機能を使用することで
        オーバーライドや型強制ができるのでご利用ください。
      `
    }
  },
  'String concatenation': {
    Title: '文字列の結合',
    Contents: {
      P1: `
        クエリから返却される属性の値に、任意の文字列を追加したいケースがあるでしょう。
        その場合、<2>concat()</2>関数を使って実現することができます。
      `,
      P2: `
        <1>concat()</1> 関数は、最大で20の引数を渡すことができ、1つの文字列に結合します。
      `,
      P3: `
        また、結合文字列に含まれる小数点を含む数値の小数点以下の桁数を制限することもできます。
        関数の最後のオプショナルの引数として、 <1>precision:</1> とともに値を設定することで実現できます。
        この例の場合、小数点以下の桁数を3桁に制限した上で、計測時間（秒）の最後に 's' を追加しています。
      `,
      P4: `
        また、 'http(s)' で始まる値の場合、クリックすると新しいページを開くことができるリンクとして表示されます。
        そのため、クエリの結果に含まれるエンティティに関連するページのリンクを表示することも可能になります。
        次の例は、属性から取得された値を使ってURLを作成したデモになります。
      `,
      H1: `本レッスンのまとめ`,
      P5: `
        <1>concat()</1> 関数を使って、値同士を結合したり、任意の文字列を追加したりすることができることを学びました。
      `
    }
  },
  Summary_L3: {
    Title: 'まとめ',
    Contents: {
      P1: `
      レベル 3: ダッシュボード作成を極めるはこれで完了です。お疲れ様でした！
      `,
      P2: `
        このセクションでは、特定の強力なNRQL機能について学習しました。
        これらのスキルはNRQLにつまづいたときに間違いなく役立つでしょう。
        データの細部まで制御できるようになりました。
      `,
      P3: `
      具体的には、以下の使い方を学びました。
      `,
      P4: `
      <0>
        <1>filter()</1>, <4>apdex()</4>, <6>rate()</6>, <7>funnel()</7>, <9>histogram()</9>
        などの高度な集約関数
      </0>
      <1><1>extrapolate</1>句の利用</1>
      <2><0>FACET CASES()</0>を使った、条件を用いたグルーピング</2>
      <3><0>filter()</0>を使ったイベントタイプを組み合わせたクエリ</3>
      <4>必要に応じて値をオーバーライド</4>
      `,
      P5: `
      これであなたもNRQL Level 3のエキスパートです！
      信じられないかもしれませんが、もっと多くの機能があるので次のセクションで紹介したいと思います。
      `
    }
  }
};

export default translate;
